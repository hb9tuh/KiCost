
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>kicost.edas.tools &#8212; kicost 1.1.20 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">kicost 1.1.20 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../edas.html" accesskey="U">kicost.edas</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kicost.edas.tools</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for kicost.edas.tools</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># MIT license</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018 by XESS Corporation / Hildo Guillardi Júnior</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in</span>
<span class="c1"># all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<span class="c1"># THE SOFTWARE.</span>

<span class="c1"># Author information.</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Hildo Guillardi Júnior&#39;</span>
<span class="n">__webpage__</span> <span class="o">=</span> <span class="s1">&#39;https://github.com/hildogjr/&#39;</span>
<span class="n">__company__</span> <span class="o">=</span> <span class="s1">&#39;University of Campinas - Brazil&#39;</span>

<span class="c1"># Libraries.</span>
<span class="kn">import</span> <span class="nn">re</span>  <span class="c1"># Regular expression parser and matches.</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">PartGroup</span>
<span class="kn">from</span> <span class="nn">..distributors</span> <span class="kn">import</span> <span class="n">get_distributors_iter</span>
<span class="kn">from</span> <span class="nn">.eda</span> <span class="kn">import</span> <span class="n">field_name_translations</span>
<span class="kn">from</span> <span class="nn">.log__</span> <span class="kn">import</span> <span class="n">debug_overview</span><span class="p">,</span> <span class="n">debug_obsessive</span><span class="p">,</span> <span class="n">debug_detailed</span><span class="p">,</span> <span class="n">debug_full</span><span class="p">,</span> <span class="n">warning</span><span class="p">,</span> <span class="n">is_debug_full</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">KiCostError</span><span class="p">,</span> <span class="n">SEPRTR</span><span class="p">,</span> <span class="n">ERR_FIELDS</span><span class="p">,</span> <span class="n">W_INCQTY</span><span class="p">,</span> <span class="n">W_REPMAN</span><span class="p">,</span> <span class="n">W_MANQTY</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;partgroup_qty&#39;</span><span class="p">,</span> <span class="s1">&#39;groups_sort&#39;</span><span class="p">,</span> <span class="s1">&#39;order_refs&#39;</span><span class="p">,</span> <span class="s1">&#39;subpartqty_split&#39;</span><span class="p">,</span> <span class="s1">&#39;group_parts&#39;</span><span class="p">]</span>

<span class="c1"># Qty and part separators are escaped by preceding with &#39;\&#39; = (?&lt;!\\)</span>
<span class="n">QTY_SEPRTR</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?&lt;!</span><span class="se">\\</span><span class="s1">)\s*[:]\s*&#39;</span>  <span class="c1"># Separator for the subpart quantity and the part number, remove the lateral spaces.</span>
<span class="n">PART_SEPRTR</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?&lt;!</span><span class="se">\\</span><span class="s1">)\s*\|\s*&#39;</span>             <span class="c1"># Separator for the part numbers in a list, remove the lateral spaces.</span>
<span class="n">PART_SEPRTR_LEGACY</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?&lt;!</span><span class="se">\\</span><span class="s1">)\s*[;,\|]\s*&#39;</span>  <span class="c1"># Legacy version</span>
<span class="n">ESC_FIND</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">\s*([;,:])\s*&#39;</span>      <span class="c1"># Used to remove backslash from escaped qty &amp; manf# separators.</span>
<span class="n">REPLICATE_MANF</span> <span class="o">=</span> <span class="s1">&#39;~&#39;</span>  <span class="c1"># Character used to replicate the last manufacture name (`manf` field) in multi-parts.</span>
<span class="n">SGROUP_SEPRTR</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>  <span class="c1"># Separator of the semi identical parts groups (parts that have the filed ignored to group).</span>
<span class="n">PRJ_STR_DECLARE</span> <span class="o">=</span> <span class="s1">&#39;prj&#39;</span>  <span class="c1"># Project string declaration attached to the beginning of each reference correspondent to one project in the multi-project files case.</span>
<span class="n">PRJPART_SPRTR</span> <span class="o">=</span> <span class="n">SEPRTR</span>  <span class="c1"># Separator between part designator and reference string. `PRJ_STR_DECLARE` + \d + `PRJPART_SPRTR` + ref</span>
<span class="n">PRJ_REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^(&#39;</span> <span class="o">+</span> <span class="n">PRJ_STR_DECLARE</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;(\d+)&#39;</span> <span class="o">+</span> <span class="n">PRJPART_SPRTR</span> <span class="o">+</span> <span class="s1">&#39;)(.*)&#39;</span><span class="p">)</span>
<span class="c1"># Control for the group-collapse presentation.</span>
<span class="n">PART_SEQ_SEPRTR</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>  <span class="c1"># Part separator for sequential grouping.</span>
<span class="n">PART_NSEQ_SEPRTR</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span>  <span class="c1"># Part separator for non-sequential grouping.</span>
<span class="n">SUB_SEPRTR</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>  <span class="c1"># Subpart separator for a part reference.</span>
<span class="n">PRJ_SEPRTR</span> <span class="o">=</span> <span class="s1">&#39;;&#39;</span>  <span class="c1"># Separator between projects when collapsed and grouped the part references.</span>
<span class="c1"># Reference string order to the spreadsheet. Use this to</span>
<span class="c1"># group the elements in sequential rows.</span>
<span class="n">BOM_ORDER</span> <span class="o">=</span> <span class="s1">&#39;u,q,d,t,y,x,c,r,s,j,p,cnn,con&#39;</span>

<span class="c1"># Characters removed from references when read the files.</span>
<span class="n">PART_REF_REGEX_NOT_ALLOWED</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[\+\(\)\*\</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">SEPRTR</span><span class="p">)</span>
<span class="c1"># Regular expression for detecting part reference ids consisting of a</span>
<span class="c1"># prefix of letters followed by a sequence of digits, such as &#39;LED10&#39;</span>
<span class="c1"># or a sequence of digits followed by a subpart number like &#39;CONN1#3&#39;.</span>
<span class="c1"># There can even be an interposer alphabetical and some special</span>
<span class="c1"># characters so &#39;LED.10&#39;, &#39;LED_10&#39;, &#39;LED_BLUE-10&#39;, &#39;TEST&amp;PIN+2&#39;,</span>
<span class="c1"># &#39;TEST+SUPPLY&#39; or &#39;R4.10&#39; is also OK.</span>
<span class="c1"># Also references with numbers at the end, just if the interlocutor,</span>
<span class="c1"># part are allowed by some EDAs or manual edition in KiCad.</span>
<span class="c1"># In the case of multiple project BOM files, the references are</span>
<span class="c1"># modified by adding the project number identification followed</span>
<span class="c1"># by `SEPRTR` definition.</span>
<span class="n">PART_REF_REGEX_SPECIAL_CHAR_REF</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\+\-\=\s\_\.\(\)\$\*\&amp;&#39;</span>  <span class="c1"># Used in next definition only (because repeat).</span>
<span class="n">PART_REF_REGEX_NUMBER</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;(?P&lt;num&gt;((?P&lt;ref_num&gt;\d+)(</span><span class="si">{sp}</span><span class="s1">(?P&lt;subpart_num&gt;\d+))?))&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sp</span><span class="o">=</span><span class="n">SUB_SEPRTR</span><span class="p">)</span>
<span class="n">PART_REF_REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^(?P&lt;prefix&gt;.*?)&#39;</span><span class="o">+</span><span class="n">PART_REF_REGEX_NUMBER</span><span class="o">+</span><span class="s1">&#39;$&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_manfcat</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="s1">&#39;manf#&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="c1"># Special case for manf#:</span>
    <span class="c1"># The manf and manf# are closely related, join them.</span>
    <span class="c1"># Note that failing to do it will produce problems if two or more parts indicates a manf, but not the manf# (#474)</span>
    <span class="n">manf</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf&#39;</span><span class="p">)</span>
    <span class="n">manf_num</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf#&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">manf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">manf_num</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">manf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">manf</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">manf_num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">manf_num</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># We use lower case and only the first word to make is less sensitive to typos</span>
    <span class="k">return</span> <span class="n">manf</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">manf_num</span>


<div class="viewcode-block" id="group_parts"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.group_parts">[docs]</a><span class="k">def</span> <span class="nf">group_parts</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">fields_merge</span><span class="p">,</span> <span class="n">c_prjs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;@brief Group common parts after preprocessing from XML or CSV files.</span>

<span class="sd">       Group common parts looking in the existent files that could be merged</span>
<span class="sd">       by the use of `fields_merge`. First group all designed parts without</span>
<span class="sd">       look the manufacture/distributors codes, after see if any will be</span>
<span class="sd">       propagated (designed part with out information and same values,</span>
<span class="sd">       footprint and so on that other that have manufacture part, receive</span>
<span class="sd">       this code).</span>
<span class="sd">       Count the quantities of each part designed using the &#39;manf#_qty&#39;</span>
<span class="sd">       field, this is important to merge subparts of different parts and</span>
<span class="sd">       parts of different BOMs (in the mode of multifiles).</span>
<span class="sd">       @param components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @param fields_merge Data fields of the `dict()` variable to be merged and ignored to make the identical components group</span>
<span class="sd">       (before be scraped in the distributors web site).</span>
<span class="sd">       @return `list()` of `dict()`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">debug_overview</span><span class="p">(</span><span class="s1">&#39;# Grouping parts...&#39;</span><span class="p">)</span>
    <span class="n">ultra_debug</span> <span class="o">=</span> <span class="n">is_debug_full</span><span class="p">()</span>

    <span class="c1"># All codes to scrape, do not include code field name of distributors</span>
    <span class="c1"># that will not be scraped. This definition is used to create and check</span>
    <span class="c1"># the identical groups or subsplit the seemingly identical parts.</span>
    <span class="n">FIELDS_MANFCAT</span> <span class="o">=</span> <span class="p">([</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39;#&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">get_distributors_iter</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;manf#&#39;</span><span class="p">])</span>
    <span class="c1"># Calculated all the fields that never have to be used to create the hash keys.</span>
    <span class="c1"># These include all the manufacture company and codes, distributors codes</span>
    <span class="c1"># recognized by the installed modules and, quantity and sub quantity of the part.</span>
    <span class="n">FIELDS_NOT_HASH</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">,</span> <span class="s1">&#39;manf&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">FIELDS_MANFCAT</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39;#_qty&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">get_distributors_iter</span><span class="p">()])</span>

    <span class="c1"># Check if was asked to merge some not allowed fields (as `manf`, `manf# ...</span>
    <span class="c1"># other ones as `desc` and even `value` and `footprint` may be merged due</span>
    <span class="c1"># the different typed (1uF and 1u) or footprint library names to the same one.</span>
    <span class="n">fields_merge</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">field_name_translations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">FIELDS_NOT_HASH</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">KiCostError</span><span class="p">(</span><span class="s1">&#39;Manufacturer/distributor codes and manufacture company &quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span>
                              <span class="s1">&#39; can</span><span class="se">\&#39;</span><span class="s1">t be ignored to create the components groups.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">ERR_FIELDS</span><span class="p">)</span>
    <span class="n">FIELDS_NOT_HASH</span> <span class="o">=</span> <span class="n">FIELDS_NOT_HASH</span> <span class="o">+</span> <span class="n">fields_merge</span>  <span class="c1"># Not use the fields do merge to create the hash.</span>

    <span class="c1"># Now partition the parts into groups of like components.</span>
    <span class="c1"># First, get groups of identical components but ignore any manufacturer&#39;s</span>
    <span class="c1"># part numbers that may be assigned. Just collect those in a list for each group.</span>
    <span class="n">debug_overview</span><span class="p">(</span><span class="s1">&#39;Getting groups of identical components...&#39;</span><span class="p">)</span>
    <span class="n">component_groups</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ref</span><span class="p">,</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># part references and field values.</span>

        <span class="c1"># Take the field keys and values of each part and create a hash.</span>
        <span class="c1"># Use the hash as the key to a dictionary that stores lists of</span>
        <span class="c1"># part references that have identical field values. The important fields</span>
        <span class="c1"># are the reference prefix (&#39;R&#39;, &#39;C&#39;, etc.), value, and footprint.</span>
        <span class="c1"># Don&#39;t use the manufacturer&#39;s part number when calculating the hash!</span>
        <span class="c1"># Also, don&#39;t use any fields with SEPRTR in the label because that indicates</span>
        <span class="c1"># a field used by a specific tool (including KiCost).</span>
        <span class="n">hash_fields</span> <span class="o">=</span> <span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FIELDS_NOT_HASH</span> <span class="ow">and</span> <span class="n">SEPRTR</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">hash_fields</span><span class="p">)))</span>

        <span class="c1"># Now add the hashed component to the group with the matching hash</span>
        <span class="c1"># or create a new group if the hash hasn&#39;t been seen before.</span>
        <span class="k">if</span> <span class="n">h</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">component_groups</span><span class="p">:</span>
            <span class="c1"># This happens if it is the first part in a group, so the group</span>
            <span class="c1"># doesn&#39;t exist yet.</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">PartGroup</span><span class="p">()</span>  <span class="c1"># Add empty structure.</span>
            <span class="n">grp</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span>  <span class="c1"># Init list of refs with first ref.</span>
            <span class="c1"># Now add the manf. part code (or None) and each distributor stock</span>
            <span class="c1"># catalogue code for this part to the group set.</span>
            <span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">:</span>
                <span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="n">get_manfcat</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="kc">True</span><span class="p">)])</span>
            <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">grp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span>
            <span class="c1"># Add next ref for identical part to the list.</span>
            <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="c1"># Also add any manufacturer&#39;s part number (or None) and each distributor</span>
            <span class="c1"># stock catalogue code to the group&#39;s list.</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">:</span>
                <span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">get_manfcat</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">f</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">ultra_debug</span><span class="p">:</span>
        <span class="n">debug_full</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">1++++++++++++++&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">component_groups</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">component_groups</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">debug_full</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                <span class="n">debug_full</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>

    <span class="c1"># Now we have groups of seemingly identical parts. But some of the parts</span>
    <span class="c1"># within a group may have different manufacturer&#39;s part numbers, and these</span>
    <span class="c1"># groups may need to be split into smaller groups of parts all having the</span>
    <span class="c1"># same manufacturer&#39;s number. Here are the cases that need to be handled:</span>
    <span class="c1">#   One manf# number (and one cat# for each distributor):</span>
    <span class="c1">#       All parts have the same manf#. Don&#39;t split this group.</span>
    <span class="c1">#   Two manf# numbers (or cat# distributor code), but one is `None`:</span>
    <span class="c1">#       Some of the parts have no manf# or distributor# but are otherwise</span>
    <span class="c1">#       identical to the other parts in the group. Don&#39;t split this group.</span>
    <span class="c1">#       Instead, propagate the non-None manf# to all the parts.</span>
    <span class="c1">#   Two manf# (or two cat# distributor code), neither is `None`:</span>
    <span class="c1">#       All parts have non-`None` manf# and distributor# numbers. Split</span>
    <span class="c1">#       the group into two smaller groups of parts all having the same</span>
    <span class="c1">#       manf# and distributor#.</span>
    <span class="c1">#   Three or more manf# (or distributor#):</span>
    <span class="c1">#       Split this group into smaller groups, each one with parts having</span>
    <span class="c1">#       the same manf# and distributor#, even if it&#39;s `None`. It&#39;s</span>
    <span class="c1">#       impossible to determine which manf# the `None` parts should be</span>
    <span class="c1">#       assigned to, so leave their manf# as `None`.</span>
    <span class="n">debug_overview</span><span class="p">(</span><span class="s1">&#39;Checking the seemingly identical parts group...&#39;</span><span class="p">)</span>
    <span class="n">new_component_groups</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Copy new component groups into this.</span>
    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">component_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">num_manfcat_codes</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">num_manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num_manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">]):</span>
            <span class="n">new_component_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
            <span class="c1"># CASE ONE and TWO:</span>
            <span class="c1"># Single manf# and distributor catalogue. Or a seemingly</span>
            <span class="c1"># identical group with just one valid manf# or cat# code,</span>
            <span class="c1"># the other one is `None`.Don&#39;t split this group. `None`</span>
            <span class="c1"># will be replaced with the propagated manufacture /</span>
            <span class="c1"># distributor catalogue code.</span>
            <span class="k">continue</span>
        <span class="c1"># TODO: This seems to be part of the above case</span>
        <span class="c1"># TODO: The case number doesn&#39;t match the above comment</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="n">num_manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">]):</span>
            <span class="n">new_component_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grp</span><span class="p">)</span>
            <span class="c1"># CASE THREE:</span>
            <span class="c1"># One manf# or cat# that is `None`. Don&#39;t split this</span>
            <span class="c1"># group. These parts are not intended to be purchased.</span>
            <span class="k">continue</span>
        <span class="c1"># CASE FOUR:</span>
        <span class="c1"># Otherwise, split the group into subgroups, each with the</span>
        <span class="c1"># same manf# and distributors catalogue codes (for that one</span>
        <span class="c1"># that will be scraped, the other ones are not considered).</span>
        <span class="k">for</span> <span class="n">i_manfcat</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">])):</span>
            <span class="n">manfcat_num</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">manfcat_num</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])[</span><span class="n">i_manfcat</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="c1"># If not have more code in the set list, is because just</span>
                    <span class="c1"># exist one. So use this as general.</span>
                    <span class="n">manfcat_num</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">manfcat_codes</span><span class="p">[</span><span class="n">f</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sub_group</span> <span class="o">=</span> <span class="n">PartGroup</span><span class="p">()</span>
            <span class="n">sub_group</span><span class="o">.</span><span class="n">manfcat_codes</span> <span class="o">=</span> <span class="n">manfcat_num</span>
            <span class="n">sub_group</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                <span class="c1"># Use get() which returns `None` if the component has no</span>
                <span class="c1"># manf# or distributor# field. That will match if the</span>
                <span class="c1"># group manf_num is also None. So append the par to the group.</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">get_manfcat</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">ref</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">manfcat_num</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">FIELDS_MANFCAT</span><span class="p">]):</span>
                    <span class="n">sub_group</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="n">new_component_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_group</span><span class="p">)</span>  <span class="c1"># Append one part of the split group.</span>
    <span class="k">if</span> <span class="n">ultra_debug</span><span class="p">:</span>
        <span class="n">debug_full</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">2++++++++++++++&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_component_groups</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">new_component_groups</span><span class="p">:</span>
            <span class="n">debug_full</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                <span class="n">debug_full</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>

    <span class="c1"># If the identical components grouped have difference in the `fields_merge`</span>
    <span class="c1"># so replace this field with a string composed line-by-line with the</span>
    <span class="c1"># occurrences (definition `SGROUP_SEPRTR`) preceded with the refs</span>
    <span class="c1"># collapsed plus `SEPRTR`. Implementation of the ISSUE #102.</span>
    <span class="n">debug_overview</span><span class="p">(</span><span class="s1">&#39;Merging field asked in the identical components groups...&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fields_merge</span><span class="p">:</span>
        <span class="n">fields_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">field_name_translations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">new_component_groups</span><span class="p">:</span>
            <span class="n">components_grp</span> <span class="o">=</span> <span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields_merge</span><span class="p">:</span>
                <span class="n">values_field</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">cmp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">cmp</span> <span class="ow">in</span> <span class="n">components_grp</span><span class="p">])</span>  <span class="c1"># Different values</span>
                <span class="n">ocurrences</span> <span class="o">=</span> <span class="p">{</span><span class="n">v_g</span><span class="p">:</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span> <span class="k">if</span> <span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_g</span><span class="p">]</span> <span class="k">for</span> <span class="n">v_g</span> <span class="ow">in</span> <span class="n">values_field</span> <span class="k">if</span> <span class="n">v_g</span><span class="p">}</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ocurrences</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="s1">&#39;desc&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ocurrences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">ocurrences</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ocurrences</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">SGROUP_SEPRTR</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">order_refs</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">SEPRTR</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ocurrences</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                        <span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">if</span> <span class="n">ultra_debug</span><span class="p">:</span>
        <span class="n">debug_full</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">3++++++++++++++&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_component_groups</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">new_component_groups</span><span class="p">:</span>
            <span class="n">debug_full</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                <span class="n">debug_full</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>

    <span class="c1"># Now get the values of all fields within the members of a group.</span>
    <span class="c1"># These will become the field values for ALL members of that group.</span>
    <span class="n">debug_overview</span><span class="p">(</span><span class="s1">&#39;Propagating field values to identical components...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">new_component_groups</span><span class="p">:</span>
        <span class="n">grp_fields</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># Multiprojects has a list of qty&#39;s</span>
        <span class="c1"># So we use a list and reduce it to one single element if needed</span>
        <span class="n">grp_qtys</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">c_prjs</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
            <span class="n">comp</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">comp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;manf#_qty&#39;</span> <span class="ow">or</span> <span class="n">key</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_qty&#39;</span><span class="p">):</span>
                    <span class="c1"># We handle this field outside the loop</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Field with no value...</span>
                    <span class="k">continue</span>  <span class="c1"># so ignore it.</span>
                <span class="k">if</span> <span class="n">grp_fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>  <span class="c1"># This field has been seen before.</span>
                    <span class="k">if</span> <span class="n">grp_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>  <span class="c1"># Flag if new field value not the same as old.</span>
                        <span class="k">raise</span> <span class="n">KiCostError</span><span class="p">(</span><span class="s1">&#39;Field value mismatch: ref=</span><span class="si">{}</span><span class="s1"> field=</span><span class="si">{}</span><span class="s1"> value=</span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1">, global=</span><span class="se">\&#39;</span><span class="si">{}</span><span class="se">\&#39;</span><span class="s1"> at group=</span><span class="si">{}</span><span class="s1">&#39;</span>
                                          <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">grp_fields</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">),</span> <span class="n">ERR_FIELDS</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># First time this field has been seen in the group, so store it.</span>
                    <span class="n">grp_fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="c1"># Add this component to the total quantity</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">c_prjs</span>
            <span class="k">if</span> <span class="s1">&#39;manf#_qty&#39;</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                <span class="n">qtys</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qtys</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">qtys</span> <span class="o">=</span> <span class="p">[</span><span class="n">qtys</span><span class="p">]</span>
                <span class="n">qty</span> <span class="o">=</span> <span class="p">[</span><span class="n">qty2float</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qtys</span><span class="p">]</span>
            <span class="c1"># Add it</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c_prjs</span><span class="p">):</span>
                <span class="n">grp_qtys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">qty</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">grp_fields</span><span class="p">[</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grp_qtys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">c_prjs</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">grp_qtys</span>
        <span class="n">grp</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">grp_fields</span>

    <span class="c1"># Now return the list of identical part groups.</span>
    <span class="k">if</span> <span class="n">ultra_debug</span><span class="p">:</span>
        <span class="n">debug_full</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">4------------&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">new_component_groups</span><span class="p">:</span>
            <span class="n">debug_full</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">)</span>
            <span class="n">debug_full</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                <span class="n">debug_full</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>
        <span class="n">debug_full</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n\n</span><span class="s1">------------&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_component_groups</span></div>


<div class="viewcode-block" id="groups_sort"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.groups_sort">[docs]</a><span class="k">def</span> <span class="nf">groups_sort</span><span class="p">(</span><span class="n">new_component_groups</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;@brief Order the groups in a alphabetical way.</span>

<span class="sd">       Put the components groups in the spreadsheet rows in a specific order</span>
<span class="sd">       using the reference string of the components. The order is defined</span>
<span class="sd">       by BOM_ORDER.</span>
<span class="sd">       @param components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return Same as input.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">debug_overview</span><span class="p">(</span><span class="s1">&#39;Sorting the groups for better visualization...&#39;</span><span class="p">)</span>

    <span class="n">ref_identifiers</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?&lt;![\W\*\/])\s*,\s*|\s*,\s*(?![\W\*\/])&#39;</span><span class="p">,</span>
                               <span class="n">BOM_ORDER</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span>
    <span class="n">component_groups_order_old</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_component_groups</span><span class="p">)))</span>
    <span class="n">component_groups_order_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">component_groups_refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reference&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">component_groups_order_old</span><span class="p">]</span>
    <span class="n">debug_obsessive</span><span class="p">(</span><span class="s1">&#39;All ref identifier: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_identifiers</span><span class="p">))</span>
    <span class="n">debug_obsessive</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> groups of components.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">component_groups_order_old</span><span class="p">)))</span>
    <span class="n">debug_obsessive</span><span class="p">(</span><span class="s1">&#39;Identifiers founded </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component_groups_refs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">ref_identifier</span> <span class="ow">in</span> <span class="n">ref_identifiers</span><span class="p">:</span>
        <span class="n">component_groups_ref_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_groups_refs</span><span class="p">))</span> <span class="k">if</span> <span class="n">ref_identifier</span> <span class="o">==</span> <span class="n">component_groups_refs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="n">debug_obsessive</span><span class="p">(</span><span class="s1">&#39;Identifier: </span><span class="si">{}</span><span class="s1"> in </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_identifier</span><span class="p">,</span> <span class="n">component_groups_ref_match</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_groups_ref_match</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If found more than one group with the reference, use the &#39;manf#&#39;</span>
            <span class="c1"># as second order criteria.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component_groups_ref_match</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">component_groups_ref_match</span><span class="p">:</span>
                        <span class="n">component_groups_order_old</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="c1"># Examine &#39;manf#&#39; and refs to get the order.</span>
                <span class="c1"># Order by refs that have &#39;manf#&#39; codes, that ones that don&#39;t have stay at the end of the group.</span>
                <span class="n">group_manf_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf#&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">component_groups_ref_match</span><span class="p">]</span>
                <span class="n">group_refs_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">h</span><span class="p">]</span><span class="o">.</span><span class="n">refs</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">component_groups_ref_match</span><span class="p">]</span>
                <span class="n">sorted_groups</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group_refs_list</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">group_manf_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>  <span class="n">group_refs_list</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
                <span class="n">debug_obsessive</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &gt; order: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group_manf_list</span><span class="p">,</span> <span class="n">sorted_groups</span><span class="p">))</span>
                <span class="n">component_groups_ref_match</span> <span class="o">=</span> <span class="p">[</span><span class="n">component_groups_ref_match</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_groups</span><span class="p">]</span>
                <span class="n">component_groups_order_new</span> <span class="o">+=</span> <span class="n">component_groups_ref_match</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">component_groups_order_old</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">component_groups_ref_match</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">component_groups_order_new</span> <span class="o">+=</span> <span class="n">component_groups_ref_match</span>
    <span class="c1"># The new order is the found refs first and at the last the not referenced in BOM_ORDER.</span>
    <span class="n">component_groups_order_new</span> <span class="o">+=</span> <span class="n">component_groups_order_old</span>  <span class="c1"># Add the missing references groups.</span>
    <span class="n">new_component_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_component_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component_groups_order_new</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_component_groups</span></div>


<div class="viewcode-block" id="subpartqty_split"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.subpartqty_split">[docs]</a><span class="k">def</span> <span class="nf">subpartqty_split</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">distributors</span><span class="p">,</span> <span class="n">split_extra_fields</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;@brief Split the components with subparts in different components.</span>

<span class="sd">       Take each part and the all manufacture/distributors combination</span>
<span class="sd">       possibility to split in subpart the components part that have</span>
<span class="sd">       more than one manufacture/distributors code.</span>
<span class="sd">       For each designator...</span>
<span class="sd">       For designator with a &quot;single subpart&quot; check with the quantity</span>
<span class="sd">       is more than one.</span>

<span class="sd">       @param components Part components in a `list()` of `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return Same as the input.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">debug_overview</span><span class="p">(</span><span class="s1">&#39;Splitting subparts in the manufacture / distributors codes...&#39;</span><span class="p">)</span>

    <span class="n">FIELDS_MANF</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="s1">&#39;#&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distributors</span><span class="p">]</span>
    <span class="n">FIELDS_MANF</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;manf#&#39;</span><span class="p">)</span>
    <span class="n">split_extra_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">split_extra_fields</span><span class="p">]</span>
    <span class="n">split_extra_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pricing&#39;</span><span class="p">)</span>

    <span class="n">split_components</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">part_ref</span><span class="p">,</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">components</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Divide the subparts in different parts keeping the other fields</span>
        <span class="c1"># (reference, description, ...).</span>
        <span class="c1"># First search for the used fields to manufacture/distributor numbers</span>
        <span class="c1"># and how many subparts are in them. Use the loop also to extract the</span>
        <span class="c1"># manufacture/distributor codes in list. Use the maximum of them.</span>
        <span class="n">fields_found</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">subparts_qty</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">subparts_manf_code</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">field_code_last</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">field_code</span> <span class="ow">in</span> <span class="n">FIELDS_MANF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field_code</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
                <span class="n">subparts</span> <span class="o">=</span> <span class="n">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">field_code</span><span class="p">])</span>
                <span class="n">subparts_qty_field</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subparts</span><span class="p">)</span>
                <span class="n">subparts_qty</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">subparts_qty</span><span class="p">,</span> <span class="n">subparts_qty_field</span><span class="p">)</span>  <span class="c1"># Quantity of sub parts.</span>
                <span class="c1"># Print a warning and an user tip in the case of different subpart quantities</span>
                <span class="c1"># associated in different `manf#`/distributors# of the same component.</span>
                <span class="k">if</span> <span class="n">subparts_qty_field</span> <span class="o">!=</span> <span class="n">subparts_qty</span><span class="p">:</span>
                    <span class="n">problem_manf_code</span> <span class="o">=</span> <span class="p">(</span><span class="n">field_code</span> <span class="k">if</span> <span class="n">subparts_qty</span> <span class="o">&gt;</span> <span class="n">subparts_qty_field</span> <span class="k">else</span> <span class="n">field_code_last</span><span class="p">)</span>
                    <span class="n">warning</span><span class="p">(</span><span class="n">W_INCQTY</span><span class="p">,</span> <span class="s1">&#39;Found a different subpart quantity between the code fields </span><span class="si">{c}</span><span class="s1"> and </span><span class="si">{lc}</span><span class="s1">.</span><span class="se">\n</span><span class="s1">&#39;</span>
                                      <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">You should consider use </span><span class="se">\&quot;</span><span class="si">{pc}</span><span class="s1">=</span><span class="si">{m}</span><span class="se">\&quot;</span><span class="s1"> on </span><span class="si">{r}</span><span class="s1"> to disambiguate that.&#39;</span>
                                      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">field_code_last</span><span class="p">,</span> <span class="n">lc</span><span class="o">=</span><span class="n">field_code</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">part_ref</span><span class="p">,</span>
                                              <span class="n">pc</span><span class="o">=</span><span class="n">problem_manf_code</span><span class="p">,</span>
                                              <span class="n">m</span><span class="o">=</span><span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">problem_manf_code</span><span class="p">])</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">subparts_qty</span> <span class="o">-</span> <span class="n">subparts_qty_field</span><span class="p">))))</span>
                <span class="n">field_code_last</span> <span class="o">=</span> <span class="n">field_code</span>
                <span class="n">fields_found</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_code</span><span class="p">)</span>
                <span class="n">subparts_manf_code</span><span class="p">[</span><span class="n">field_code</span><span class="p">]</span> <span class="o">=</span> <span class="n">subparts</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fields_found</span><span class="p">:</span>
            <span class="n">split_components</span><span class="p">[</span><span class="n">part_ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">part</span>
            <span class="c1"># TODO What about other fields?</span>
            <span class="k">continue</span>  <span class="c1"># If not manf/distributor code pass to next.</span>
        <span class="c1"># Divide the `manf` manufacture name.</span>
        <span class="n">subparts_manf</span> <span class="o">=</span> <span class="n">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subparts_manf</span><span class="p">)</span> <span class="o">!=</span> <span class="n">subparts_qty</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subparts_manf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If just one `manf`assumes that is for all.</span>
                <span class="n">subparts_manf</span> <span class="o">=</span> <span class="p">[</span><span class="n">subparts_manf</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="n">subparts_qty</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Exception `manf` and `manf#` length doesn&#39;t match, fill with &#39;&#39; at the end.</span>
                <span class="n">subparts_manf</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">subparts_qty</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">subparts_manf</span><span class="p">)))</span>
        <span class="c1"># Divide the pricing fields (won&#39;t apply quantity, this is why this is a separated list)</span>
        <span class="n">subparts_extra</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">part</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">extra_field</span> <span class="ow">in</span> <span class="n">split_extra_fields</span><span class="o">+</span><span class="p">[</span><span class="s1">&#39;avail&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="n">extra_field</span> <span class="ow">or</span> <span class="n">field</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">extra_field</span><span class="p">):</span>
                    <span class="n">subparts_extra</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_list</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">debug_detailed</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> &gt;&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_ref</span><span class="p">,</span> <span class="n">fields_found</span><span class="p">))</span>

        <span class="c1"># Second, if more than one subpart, split the sub parts as</span>
        <span class="c1"># new components with the same description, footprint, and</span>
        <span class="c1"># so on... Get the subpart.</span>
        <span class="n">is_multi</span> <span class="o">=</span> <span class="n">subparts_qty</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">part_actual</span> <span class="o">=</span> <span class="n">part</span>
        <span class="n">part_actual_value</span> <span class="o">=</span> <span class="n">part_actual</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">subpart_part</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">subpart_qty</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">p_manf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Add the split subparts.</span>
        <span class="k">for</span> <span class="n">subparts_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subparts_qty</span><span class="p">):</span>
            <span class="c1"># Create a sub component based on the main component with</span>
            <span class="c1"># the subparts. Modify the designator and the part. Create</span>
            <span class="c1"># a sub quantity field.</span>
            <span class="k">if</span> <span class="n">is_multi</span><span class="p">:</span>
                <span class="n">subpart_actual</span> <span class="o">=</span> <span class="n">part_actual</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">subpart_actual</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{v}</span><span class="s1"> - p</span><span class="si">{idx}</span><span class="s1">/</span><span class="si">{total}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">part_actual_value</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">subparts_index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">subparts_qty</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subpart_actual</span> <span class="o">=</span> <span class="n">part_actual</span>
            <span class="n">subpart_qty_prior</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Use the last cycle variable to warn the user about</span>
            <span class="n">p_manf_code_prior</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># different quantities in the fields `manf#` and `cat#`.</span>
            <span class="n">field_manf_dist_code_prior</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">field_manf_dist_code</span> <span class="ow">in</span> <span class="n">fields_found</span><span class="p">:</span>
                <span class="c1"># For each manufacture/distributor code take the same order of</span>
                <span class="c1"># the code list and split in each subpart. When not founded one</span>
                <span class="c1"># part, do not add.</span>
                <span class="c1"># e.g. U1:{&#39;manf#&#39;:&#39;PARTG1;PARTG2;PARTG3&#39;, &#39;mouser#&#39;&#39;PARTM1;PARTM2&#39;}</span>
                <span class="c1"># result:</span>
                <span class="c1"># U1.1:{&#39;manf#&#39;:&#39;PARTG1&#39;, &#39;mouser#&#39;:&#39;PARTM1&#39;}</span>
                <span class="c1"># U1.2:{&#39;manf#&#39;:&#39;PARTG2&#39;, &#39;mouser#&#39;:&#39;PARTM2&#39;}</span>
                <span class="c1"># U1.3:{&#39;manf#&#39;:&#39;PARTG3&#39;}</span>
                <span class="k">if</span> <span class="n">subparts_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subparts_manf_code</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="n">p_manf_code</span> <span class="o">=</span> <span class="n">subparts_manf_code</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="p">][</span><span class="n">subparts_index</span><span class="p">]</span>
                <span class="n">subpart_qty</span><span class="p">,</span> <span class="n">subpart_part</span> <span class="o">=</span> <span class="n">manf_code_qtypart</span><span class="p">(</span><span class="n">p_manf_code</span><span class="p">)</span>
                <span class="n">subpart_actual</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_part</span>
                <span class="n">subpart_actual</span><span class="p">[</span><span class="n">field_manf_dist_code</span><span class="o">+</span><span class="s1">&#39;_qty&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_qty</span>
                <span class="n">debug_obsessive</span><span class="p">(</span><span class="n">subpart_actual</span><span class="p">)</span>
                <span class="c1"># Warn the user about different quantities asigned to different `manf#`</span>
                <span class="c1"># and catalogue number of same part/subpart. Which may be a type error by</span>
                <span class="c1"># the user.</span>
                <span class="k">if</span> <span class="n">p_manf_code</span> <span class="ow">and</span> <span class="n">p_manf_code_prior</span> <span class="ow">and</span> <span class="n">subpart_qty_prior</span> <span class="o">!=</span> <span class="n">subpart_qty</span><span class="p">:</span>
                    <span class="n">warning</span><span class="p">(</span><span class="n">W_INCQTY</span><span class="p">,</span> <span class="s1">&#39;Different quantities signed between </span><span class="se">\&quot;</span><span class="si">{f}</span><span class="s1">=</span><span class="si">{c}</span><span class="se">\&quot;</span><span class="s1"> and </span><span class="se">\&quot;</span><span class="si">{fl}</span><span class="s1">=</span><span class="si">{cl}</span><span class="se">\&quot;</span><span class="s1"> at </span><span class="se">\&quot;</span><span class="si">{r}</span><span class="se">\&quot;</span><span class="s1">. Make sure that is right.&#39;</span><span class="o">.</span>
                                      <span class="nb">format</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">field_manf_dist_code</span><span class="p">,</span> <span class="n">fl</span><span class="o">=</span><span class="n">field_manf_dist_code_prior</span><span class="p">,</span>
                                             <span class="n">c</span><span class="o">=</span><span class="n">p_manf_code</span><span class="p">,</span> <span class="n">cl</span><span class="o">=</span><span class="n">p_manf_code_prior</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">order_refs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="c1"># Memorize prior value for the above warning</span>
                <span class="n">subpart_qty_prior</span> <span class="o">=</span> <span class="n">subpart_qty</span>
                <span class="n">p_manf_code_prior</span> <span class="o">=</span> <span class="n">p_manf_code</span>
                <span class="n">field_manf_dist_code_prior</span> <span class="o">=</span> <span class="n">field_manf_dist_code</span>
            <span class="k">if</span> <span class="n">is_multi</span><span class="p">:</span>
                <span class="c1"># Update other fields</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">subparts_extra</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">subpart_actual</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">subparts_index</span><span class="p">]</span> <span class="k">if</span> <span class="n">subparts_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
                <span class="c1"># Update the split `manf`(manufactures names).</span>
                <span class="k">if</span> <span class="n">subparts_manf</span><span class="p">[</span><span class="n">subparts_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">REPLICATE_MANF</span><span class="p">:</span>
                    <span class="c1"># If the actual manufacture name is the defined as `REPLICATE_MANF`</span>
                    <span class="c1"># replicate the last one.</span>
                    <span class="n">p_manf</span> <span class="o">=</span> <span class="n">subparts_manf</span><span class="p">[</span><span class="n">subparts_index</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">p_manf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">warning</span><span class="p">(</span><span class="n">W_REPMAN</span><span class="p">,</span> <span class="s1">&#39;Asking to repeat a manufacturer in the first entry (at </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span>
                                      <span class="nb">format</span><span class="p">(</span><span class="n">order_refs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">components</span><span class="o">.</span><span class="n">keys</span><span class="p">()))[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">subpart_actual</span><span class="p">[</span><span class="s1">&#39;manf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_manf</span>
                <span class="c1"># Update the reference of the part.</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">part_ref</span> <span class="o">+</span> <span class="n">SUB_SEPRTR</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">subparts_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ref</span> <span class="o">=</span> <span class="n">part_ref</span>
            <span class="n">split_components</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">subpart_actual</span>
    <span class="k">return</span> <span class="n">split_components</span></div>


<span class="k">def</span> <span class="nf">qty2float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">warning</span><span class="p">(</span><span class="n">W_MANQTY</span><span class="p">,</span> <span class="s1">&#39;Malformed `manf#_qty`: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="mf">1.0</span>


<div class="viewcode-block" id="partgroup_qty"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.partgroup_qty">[docs]</a><span class="k">def</span> <span class="nf">partgroup_qty</span><span class="p">(</span><span class="n">component</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;@brief Take the components grouped quantity.</span>

<span class="sd">       Calculate the string of the quantity of the group parsing the</span>
<span class="sd">       reference (design) quantity and the sub quantity (in case that</span>
<span class="sd">       was a sub part of a manufacture/distributor code).</span>
<span class="sd">       In the case of the multifiles BOM (and future revision of the</span>
<span class="sd">       code) just use the &#39;manf#_qty&#39; field that in `group_parts()`</span>
<span class="sd">       recorded the quantities used in each project.</span>

<span class="sd">       @param components Part component `dict()`, format given by the EDA modules.</span>
<span class="sd">       @return Quantity of the manf# part used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qty</span> <span class="o">=</span> <span class="n">component</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf#_qty&#39;</span><span class="p">)</span>

    <span class="n">debug_obsessive</span><span class="p">(</span><span class="s1">&#39;Qty&gt;&gt; </span><span class="si">{}</span><span class="se">\t</span><span class="s1"> </span><span class="si">{}</span><span class="s1">*</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">,</span> <span class="n">qty</span><span class="p">,</span> <span class="n">component</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manf#&#39;</span><span class="p">)))</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qty</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c1"># Multifiles BOM case, the quantities in the list represent</span>
        <span class="c1"># each project read by the order. Do not `CEILING` because</span>
        <span class="c1"># this is will be made in the total columns that sum all</span>
        <span class="c1"># the quantities needed in all projects BOMs.</span>
        <span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;={{}}*(</span><span class="si">{qp}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qp</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">qty</span><span class="p">]</span>
        <span class="n">number</span> <span class="o">=</span> <span class="p">[</span><span class="n">qty2float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">qty</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">qty</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">qty</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
        <span class="c1"># No qty or just 1</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;={{}}*</span><span class="si">{qty}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qty</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">))</span>
        <span class="n">number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">refs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># A number (could be a fraction)</span>
        <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;=CEILING({{}}*</span><span class="si">{q}</span><span class="s1">,1)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">qty</span><span class="p">)</span>
        <span class="n">number</span> <span class="o">=</span> <span class="n">qty2float</span><span class="p">(</span><span class="n">qty</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">,</span> <span class="n">number</span></div>


<span class="k">def</span> <span class="nf">subpart_list</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">legacy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    @brief Split the subpart by the `PART_SEPRTR`definition.</span>

<span class="sd">    Get the list of sub parts manufacture / distributor code</span>
<span class="sd">    numbers stripping the spaces and keeping the sub part</span>
<span class="sd">    quantity information, these have to be separated by</span>
<span class="sd">    PART_SEPRTR definition.</span>

<span class="sd">    @param part Manufacture code part `str`.</span>
<span class="sd">    @return List of manufacture code parts.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">PART_SEPRTR_LEGACY</span> <span class="k">if</span> <span class="n">legacy</span> <span class="k">else</span> <span class="n">PART_SEPRTR</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">manf_code_qtypart</span><span class="p">(</span><span class="n">subpart</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;@brief Get the quantity and the part code of the sub part</span>
<span class="sd">       manufacture / distributor. Test if was pre or post</span>
<span class="sd">       multiplied by a constant.</span>

<span class="sd">       Setting QTY_SEPRTR as &#39;:&#39;, we have</span>
<span class="sd">       &#39; 4.5 : ADUM3150BRSZ-RL7&#39; -&gt; (&#39;4.5&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;4/5  : ADUM3150BRSZ-RL7&#39; -&gt; (&#39;4/5&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;7:ADUM3150BRSZ-RL7&#39; -&gt; (&#39;7&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;ADUM3150BRSZ-RL7 :   7&#39; -&gt; (&#39;7&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;ADUM3150BRSZ-RL7&#39; -&gt; (&#39;1&#39;, &#39;ADUM3150BRSZ-RL7&#39;)</span>
<span class="sd">       &#39;ADUM3150BRSZ-RL7:&#39; -&gt; (&#39;1&#39;, &#39;ADUM3150BRSZ-RL7&#39;) forgot the qty understood &#39;1&#39;</span>

<span class="sd">       @param Part that way have different than ONE quantity. Intended as one element of the list of `subpart_list()`.</span>
<span class="sd">       @return (qty, manf#) Quantity and the manufacture code.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">strings</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">QTY_SEPRTR</span><span class="p">,</span> <span class="n">subpart</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Search for numbers, matching with simple, frac and decimal ones.</span>
        <span class="n">num_format</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*[\-\+]?\s*[0-9]*\s*[\.\/]*\s*?[0-9]*\s*$&quot;</span><span class="p">)</span>
        <span class="n">string0_test</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">num_format</span><span class="p">,</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">string1_test</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">num_format</span><span class="p">,</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">string0_test</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">string1_test</span><span class="p">:</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">string0_test</span> <span class="ow">and</span> <span class="n">string1_test</span><span class="p">:</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">string0_test</span> <span class="ow">and</span> <span class="n">string1_test</span><span class="p">:</span>
            <span class="c1"># May be founded a just numeric manufacture/distributor part,</span>
            <span class="c1"># in this case, the quantity is a shortest string not</span>
            <span class="c1"># considering &quot;.&quot; and &quot;/&quot; marks.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\.\/]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\.\/]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qty</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="n">strings</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">qty</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">qty</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qty</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="n">part</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>
    <span class="n">part</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ESC_FIND</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>  <span class="c1"># Remove any escape backslashes preceding PART_SEPRTR.</span>
    <span class="n">debug_obsessive</span><span class="p">(</span><span class="s1">&#39;part/qty&gt;&gt; </span><span class="si">{}</span><span class="se">\t\t</span><span class="s1">part&gt;&gt;</span><span class="si">{}</span><span class="se">\t</span><span class="s1">qty&gt;&gt;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">subpart</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">qty</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qty</span><span class="p">,</span> <span class="n">part</span>


<span class="k">def</span> <span class="nf">get_refnum</span><span class="p">(</span><span class="n">refnum</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">refnum</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">refnum</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">convert_to_ranges</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="c1"># Collapse a list of numbers into sorted, comma-separated, hyphenated ranges.</span>
    <span class="c1"># e.g.: 3,4,7,8,9,10,11,13,14 =&gt; 3,4,7-11,13,14</span>

    <span class="k">def</span> <span class="nf">to_int</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>

    <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">get_refnum</span><span class="p">)</span>  <span class="c1"># Sort all the numbers.</span>
    <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>  <span class="c1"># Convert strings to `int` if possible.</span>
    <span class="n">num_ranges</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># No ranges found yet since we just started.</span>
    <span class="n">range_start</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># First possible range is at the start of the list of numbers.</span>

    <span class="c1"># Go through the list of numbers looking for 3 or more sequential numbers.</span>
    <span class="k">while</span> <span class="n">range_start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
        <span class="n">num_range</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_start</span><span class="p">]</span>  <span class="c1"># Current range starts off as a single number.</span>
        <span class="n">next_range_start</span> <span class="o">=</span> <span class="n">range_start</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># The next possible start of a range.</span>
        <span class="c1"># Part references with subparts are never included in ref ranges.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_range</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">num_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_range</span><span class="p">)</span>
            <span class="n">range_start</span> <span class="o">=</span> <span class="n">next_range_start</span>
            <span class="k">continue</span>
        <span class="c1"># Look for sequences of three or more sequential numbers.</span>
        <span class="k">for</span> <span class="n">range_end</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">range_start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">range_end</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">break</span>  <span class="c1"># Ref with subpart, so can&#39;t be in a ref range.</span>
            <span class="k">if</span> <span class="n">range_end</span> <span class="o">-</span> <span class="n">range_start</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_end</span><span class="p">]</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_start</span><span class="p">]:</span>
                <span class="k">break</span>  <span class="c1"># Non-sequential numbers found, so break out of loop.</span>
            <span class="c1"># Otherwise, extend the current range.</span>
            <span class="n">num_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">nums</span><span class="p">[</span><span class="n">range_start</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">range_end</span><span class="p">]]</span>
            <span class="c1"># 3 or more sequential numbers found, so next possible range must start after this one.</span>
            <span class="n">next_range_start</span> <span class="o">=</span> <span class="n">range_end</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Append the range (or single number) just found to the list of range.</span>
        <span class="n">num_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_range</span><span class="p">)</span>
        <span class="c1"># Point to the start of the next possible range and keep looking.</span>
        <span class="n">range_start</span> <span class="o">=</span> <span class="n">next_range_start</span>

    <span class="k">return</span> <span class="n">num_ranges</span>


<div class="viewcode-block" id="order_refs"><a class="viewcode-back" href="../../../kicost.edas.html#kicost.edas.tools.order_refs">[docs]</a><span class="k">def</span> <span class="nf">order_refs</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">collapse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ref_sep</span><span class="o">=</span><span class="n">PART_NSEQ_SEPRTR</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;@brief Collapse list of part references into a sorted, comma-separated list of hyphenated ranges. This is intended as opposite of `split_refs()`</span>
<span class="sd">       @param refs Designator/references `list()`.</span>
<span class="sd">       @return References in a organized view way.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">prefix_nums</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># Contains a list of numbers for each distinct prefix.</span>
    <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">refs</span><span class="p">:</span>
        <span class="c1"># Partition each part reference into its beginning part prefix and ending number.</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">PART_REF_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;prefix&#39;</span><span class="p">)</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="n">num</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="c1"># Append the number to the list of numbers for this prefix, or create a list</span>
        <span class="c1"># with a single number if this is the first time a particular prefix was encountered.</span>
        <span class="n">prefix_nums</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="c1"># Convert the list of numbers for each ref prefix into ranges.</span>
    <span class="k">if</span> <span class="n">collapse</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">prefix_nums</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">prefix_nums</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_to_ranges</span><span class="p">(</span><span class="n">prefix_nums</span><span class="p">[</span><span class="n">prefix</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">prefix_nums</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">prefix_nums</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">get_refnum</span><span class="p">)</span>

    <span class="c1"># Combine the prefixes and number ranges back into part references.</span>
    <span class="n">collapsed_refs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">first_ref</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">nums</span> <span class="ow">in</span> <span class="n">prefix_nums</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Is this a multiproject ref?</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">PRJ_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">prj_prefix</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prj_prefix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Work on this group of references</span>
        <span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># Convert a range list into a collapsed part reference:</span>
                <span class="c1"># e.g., &#39;R10-R15&#39; from &#39;R&#39;:[10,15].</span>
                <span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}{1}{3}{0}{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">PART_SEQ_SEPRTR</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Convert a single number into a simple part reference: e.g., &#39;R10&#39;.</span>
                <span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">num</span>
            <span class="k">if</span> <span class="n">first_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">first_ref</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="c1"># Add them to the list</span>
        <span class="k">if</span> <span class="n">prj_prefix</span><span class="p">:</span>
            <span class="c1"># Add one entry for mutiprojects, it contains all the similar refs for this project</span>
            <span class="n">collapsed_refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prj_prefix</span> <span class="o">+</span> <span class="n">ref_sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">refs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collapsed_refs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">refs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">prj_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Separate multiproject refs in different lines</span>
        <span class="n">ref_sep</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="n">collapsed_refs</span> <span class="o">=</span> <span class="n">ref_sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">collapsed_refs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">collapsed_refs</span><span class="p">,</span> <span class="n">first_ref</span>  <span class="c1"># Return the collapsed par references.</span></div>


<span class="k">def</span> <span class="nf">split_refs</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;@brief Split string grouped references into a unique designator. This is intended as opposite of `order_refs(?, collapse=True)`</span>

<span class="sd">       &#39;C17/18/19/20&#39; --&gt; [&#39;C17&#39;,&#39;C18&#39;,&#39;C19&#39;,&#39;C20&#39;]</span>
<span class="sd">       &#39;C17\18\19\20&#39; --&gt; [&#39;C17&#39;,&#39;C18&#39;,&#39;C19&#39;,&#39;C20&#39;]</span>
<span class="sd">       &#39;D33-D36&#39; --&gt; [&#39;D33&#39;,&#39;D34&#39;,&#39;D35&#39;,&#39;D36&#39;]</span>
<span class="sd">       &#39;D33-36&#39; --&gt; [&#39;D33&#39;,&#39;D34&#39;,&#39;D35&#39;,&#39;D36&#39;]</span>
<span class="sd">       Also ignore some characters as &#39;.&#39; or &#39;:&#39; used in some cases of references.</span>

<span class="sd">       @param text Designator/references worn by a group of parts.</span>
<span class="sd">       @return Designator/references `list()` split.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">partial_ref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; *[,; ] *&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>  <span class="c1"># Split ignoring the spaces.</span>
    <span class="n">refs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">partial_ref</span><span class="p">:</span>
        <span class="c1"># Remove invalid characters. Changed `PART_REF_REGEX_SPECIAL_CHAR_REF` definition and allowed special characters.</span>
        <span class="c1"># ref = re.sub(&#39;\+$&#39;, &#39;p&#39;, ref) # Finishing &quot;+&quot;.</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">PART_REF_REGEX_NOT_ALLOWED</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>  <span class="c1"># Generic special characters not allowed. To work around #ISSUE #89.</span>
        <span class="c1"># ref = re.sub(&#39;\-+&#39;, &#39;-&#39;, ref) # Double &quot;-&quot;.</span>
        <span class="c1"># ref = re.sub(&#39;^\-&#39;, &#39;&#39;, ref) # Starting &quot;-&quot;.</span>
        <span class="c1"># ref = re.sub(&#39;\-$&#39;, &#39;n&#39;, ref) # Finishing &quot;-&quot;.</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\w+\d&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\D+&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
                <span class="n">designator_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\D+&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
                <span class="n">designator_name</span> <span class="o">+=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^d*\W&#39;</span><span class="p">,</span> <span class="n">split_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">designator_name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">split_nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split_nums</span><span class="p">))]</span>

                <span class="c1"># Some EDAs may use some separator in the reference numeric parts, as</span>
                <span class="c1"># Altium that use &quot;.&quot; (or even other) e.g. &quot;R2.1,R2.2&quot; to the same &quot;R2&quot;</span>
                <span class="c1"># replicated between schematics / rooms.</span>
                <span class="n">base_split_nums</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\d+\D&#39;</span><span class="p">,</span> <span class="n">split_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\D*(\d+)$&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">split_nums</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">split_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">split_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                    <span class="k">continue</span>
                <span class="c1"># split = [designator_name+str(split[i]) for i in range(len(split)) ]</span>
                <span class="n">split</span> <span class="o">=</span> <span class="p">[</span><span class="n">designator_name</span> <span class="o">+</span> <span class="n">base_split_nums</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">split</span><span class="p">))]</span>

                <span class="n">refs</span> <span class="o">+=</span> <span class="n">split</span>
            <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[/</span><span class="se">\\</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
                <span class="n">designator_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\D+&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">split_nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;^&#39;</span><span class="o">+</span><span class="n">designator_name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[/</span><span class="se">\\</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="p">)]</span>
                <span class="n">refs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">designator_name</span><span class="o">+</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">split_nums</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The designator name is not for a group of components and</span>
            <span class="c1"># &quot;\&quot;, &quot;/&quot; or &quot;-&quot; is part of the name. This characters have</span>
            <span class="c1"># to be removed.</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[\-\/</span><span class="se">\\</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">PART_REF_REGEX</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">):</span>
                <span class="c1"># Add a &#39;0&#39; number at the end to be compatible with KiCad/KiCost</span>
                <span class="c1"># ref strings. This may be missing in the hand made BoM.</span>
                <span class="n">ref</span> <span class="o">+=</span> <span class="s1">&#39;0&#39;</span>
            <span class="n">refs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ref</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">refs</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">kicost 1.1.20 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../edas.html" >kicost.edas</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">kicost.edas.tools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, XESS Corporation.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>